import pytest
import sillyorm
import tempfile
import pathlib
import sqlalchemy
from sillyorm.exceptions import SillyORMException
from .libtest import with_test_registry, assert_db_columns


@with_test_registry()
def test_migration_helpers(registry):
    class TestModel1(sillyorm.model.Model):
        _name = "test_model"

        field1 = sillyorm.fields.String()

    class TestModel2(sillyorm.model.Model):
        _name = "test_model"

        field1 = sillyorm.fields.String(length=123)
        field2 = sillyorm.fields.Text()

    class TestModel3(sillyorm.model.Model):
        _name = "test_model"

        field1 = sillyorm.fields.String(length=123)
        field2 = sillyorm.fields.Text()
        field3 = sillyorm.fields.Text()

    # usually you'd do this by inheriting the Registry class, but we use @with_test_registry here and can't really touch the registry class..
    # so we go the hacky route^^
    registry._table_cmp_should_include = lambda obj, name, type_, reflected, compare_to: not (
        type_ == "table" and name in ["alembic_version", "alembic_version_2"]
    )

    tmpdir_obj = tempfile.TemporaryDirectory()
    tmpdir = pathlib.Path(tmpdir_obj.name)
    ALEMBIC_MIGRATION_FOLDER1 = pathlib.Path(f"{tmpdir}/migrations1")
    ALEMBIC_MIGRATION_FOLDER1.mkdir(parents=True, exist_ok=True)
    ALEMBIC_MIGRATION_FOLDER2 = pathlib.Path(f"{tmpdir}/migrations2")
    ALEMBIC_MIGRATION_FOLDER2.mkdir(parents=True, exist_ok=True)

    def do_migration(model):
        registry.reset_full()
        registry.register_model(model)
        registry.resolve_tables()
        sillyorm.migration_helpers.helper_do_migrate()
        assert sillyorm.migration_helpers.helper_gen_migrations("autogenerated")
        sillyorm.migration_helpers.helper_do_migrate()
        assert not sillyorm.migration_helpers.helper_gen_migrations("autogenerated")
        registry.init_db_tables(automigrate="none")

    def do_migration_downgrade(model, to_rev):
        registry.reset_full()
        registry.register_model(model)
        registry.resolve_tables()
        sillyorm.migration_helpers.helper_do_migrate(to_rev, downgrade=True)
        registry.init_db_tables(automigrate="none")

    sillyorm.migration_helpers.helper_init(registry, str(ALEMBIC_MIGRATION_FOLDER1))

    do_migration(TestModel1)

    assert_db_columns(
        registry,
        "test_model",
        [
            ("id", sqlalchemy.sql.sqltypes.INTEGER()),
            ("field1", sqlalchemy.sql.sqltypes.VARCHAR(length=255)),
        ],
    )

    do_migration(TestModel2)

    assert_db_columns(
        registry,
        "test_model",
        [
            ("id", sqlalchemy.sql.sqltypes.INTEGER()),
            ("field1", sqlalchemy.sql.sqltypes.VARCHAR(length=123)),
            ("field2", sqlalchemy.sql.sqltypes.TEXT()),
        ],
    )

    # we should definitely NOT have this table yet
    assert not sqlalchemy.inspect(registry.engine).has_table("alembic_version_2")

    sillyorm.migration_helpers.helper_init(
        registry, str(ALEMBIC_MIGRATION_FOLDER2), version_table="alembic_version_2"
    )

    do_migration(TestModel3)

    # now the table should exist..
    assert sqlalchemy.inspect(registry.engine).has_table("alembic_version_2")

    assert_db_columns(
        registry,
        "test_model",
        [
            ("id", sqlalchemy.sql.sqltypes.INTEGER()),
            ("field1", sqlalchemy.sql.sqltypes.VARCHAR(length=123)),
            ("field2", sqlalchemy.sql.sqltypes.TEXT()),
            ("field3", sqlalchemy.sql.sqltypes.TEXT()),
        ],
    )

    # downgrade

    do_migration_downgrade(TestModel2, "base")

    assert_db_columns(
        registry,
        "test_model",
        [
            ("id", sqlalchemy.sql.sqltypes.INTEGER()),
            ("field1", sqlalchemy.sql.sqltypes.VARCHAR(length=123)),
            ("field2", sqlalchemy.sql.sqltypes.TEXT()),
        ],
    )
